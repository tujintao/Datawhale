第三个任务（2天）
排序
实现归并排序、快速排序、插入排序、冒泡排序、选择排序、堆排序（选做）（完成leetcode上的返回滑动窗口中的最大值(239)，这是上一期第三天的任务进行保留（涉及队列可以对第二天进行整理复习））
编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素
二分查找
实现一个有序数组的二分查找算法
实现模糊二分查找算法（比如大于等于给定值的第一个元素）
对应的 LeetCode 练习题
Sqrt(x) （x 的平方根）

### [归并排序](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)

### [快速排序](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)

### [选择排序](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)

### [插入排序](https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)

插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

### [堆排序](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F#C++)

这个比较生疏了，就接着task1中实现的Vector实现了优先队列，虽说都是书上的代码，但是比较系统的梳理了下堆的性质，上滤、下滤、插入、删除、排序的过程等。

### 第K大（top k问题）

##### 解法1：

​	我们可以对这个乱序数组按照从大到小先行排序，然后取出前k大，总的时间复杂度为O(n*logn + k)。

##### 解法2:

​	利用选择排序或冒泡排序，K次选择后即可得到第k大的数。因为每轮选择必有一个元素就位。总的时间复杂度为O(n*k)

##### 解法3:



> 《编程之美》中的部分我就直接引用了
>
> 回忆一下快速排序，快排中的每一步，都是待排数据分作两组，其中一组数据的任何一个数都比另一组中的任意数大，在对两组分别做类似的操作，然后继续下去。。
>
> 假设N个数存储在S中，我们从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb.Sa中的元素大于等于X，Sb中的元素小于X
>
> 这时，有两种可能性:
>
> 1.Sa中元素的个数小于K, Sa中所有的数和Sb中最大的K-|Sa|个元素（|Sa|指Sa中元素的个数）就是数组S中最大的K个数；
>
> 2.Sa中元素的个数大于或等于K，则需要返回Sa中最大的K个元素
>
>

时间复杂度 $O(N *{\log}_{2}{K})​$约等于O(N)

空间复杂度 O(1)

##### 解法4

>  寻找N个数中最大的K个数，本质上就是寻找最大的K个数中最小的那个,也就是第K大的数。可以使用二分搜索的策略。对于一个给定的数p，可以在$O(N)$的时间复杂度内找出所有不小于p的数。假如N个数中最大的数为$[V_{min}, V_{max}]$之间。那么，可以在这个区间内二分搜索N个数中的第K大数p。
>
> ```c++
> while(Vmax - Vmin >delta)
> {
>     Vmid = Vmin + (Vmax - Vmin) * 0.5;
>     if (f(arr, N, Vmid) >= K)
>         Vmin = Vmid;
>     else
>         Vmax = Vmid;
> }
> ```
>
> 伪代码中$f(arr,N,V_{mid})$返回数组arr[0, ..., N-1]中大于等于$V_{mid}$的数的个数。上述为嘛中，delta的取值要比所有N个数中的任意连个不相等的元素差值最小值小

时间复杂度 O(N * \log_{2}(|{V}_{max}-{V}_{min}|)/delta)

由于delta的取值要比所有N个数中的任意两个不相等的元素差值的最小值小，因此时间复杂度跟数据分布相关。在数据分布平均的情况下，时间复杂度为上述。

##### 解法5

> 如果N很大呢， 100亿？这个时候数据不能全部装加入内存，所以要求尽可能少地遍历所有数据。此时，可以用容量为K的最小堆来存储最大的K个数。最小堆的对顶元素就是最大K歌数中最小的一个。每次新考虑一个数X，如果X比堆顶的元素Y小，则不需要改变原来的对，因为这个元素比最大的K个数小。如果X比对顶元素大，那么用X替换堆顶的元素Y。在X替换堆顶元素Y之后，X可能破坏最小堆的结构（每个节点都比它的父节点大)。需要更新堆来维持堆的性质。更新过程花费的时间复杂度为$O(\log_{2}K)$

```c++
if (X > h[0])
{
    h[0] = X;
    while (q >= K) break;
    if ((q < K - 1) && (h[q+1] < h[q]))
        q = q + 1;
    if (h[q] < h[p])
    {
        t = h[p];
        h[p] = h[q];
        h[q] = t;
        p = q;
    }
}
```

时间复杂度 O(\log_{2}K)

空间复杂度 O({1})

##### 解法6

> ​	上面类快速排序的方法平均时间复杂度是现行的。能否有确定的线性算法呢？是否可以通过改进计数排序、基数排序等来得到一个更高效的算法呢？答案是肯定的。但算法的适用范围会受到一定的限制。
>
> 如果所有N个数都是正整数，且他们的取值范围不太大，可以考虑申请空间，记录每个整数出现的次数,然后在从大到小取最大的K个。比如，所有整数都在(0, MAXN)区间中的话，利用一个数组count[MAXN]来记录每个整数出现的个数(count[i])表示整数在所有整数中出现的个数)。我们只需要扫描一遍就可以得到count数组。然后寻找第K大的元素。

```c++
for (sumCount = 0, v = MAXN - 1; v >= 0; v--)
{
    sumCount += count[v];
    if (sumCount >= K)
        break;
}
return v;
```



二分查找 和 lower_bound我已经在task1中实现过了